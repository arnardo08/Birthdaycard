<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Happy Birthday Massiel</title>
  <link href="https://fonts.googleapis.com/css2?family=Patrick+Hand&family=Great+Vibes&display=swap" rel="stylesheet">
  <style>
    /* incluir padding dentro de las medidas para evitar scroll inesperado */
    *, *::before, *::after { box-sizing: border-box; }
    body {
      margin: 0;
      background: black;
      /* ocultar scrollbars y mantener el contenido dentro de la ventana
         (box-sizing hace que los paddings no aumenten el tamaño total) */
      overflow: hidden;
      /* más espacio a los lados para que letras con cola no se corten */
      padding-inline: 48px;
  /* espacio superior para que la parte alta de las letras no se corte */
  padding-top: 40px;
      font-family: 'Patrick Hand', cursive;
      color: white;
      display: flex;
      justify-content: center;
      align-items: center;
      flex-direction: column;
      height: 100vh;
      position: relative;
    }

    h1, h2 {
      position: relative;
      /* aseguramos por si acaso que estén por encima del canvas */
      z-index: 3;
      text-align: center;
      pointer-events: none;
      /* limitar ancho para que escale bien y se mantenga centrado */
      max-width: 92vw;
      width: 100%;
    }

    h1 {
      /* más grande y responsivo: usa vw para adaptarse al ancho de pantalla */
      font-size: clamp(2.4rem, 6.5vw, 6rem);
      margin: 0;
      color: white;
      animation: popUp 0.6s ease-out forwards;
    }

    h2 {
      /* Usamos una fuente script más elegante y un tamaño responsive para que "Massiel" no se vea gigante */
      font-family: 'Great Vibes', cursive;
    /* un poco más grande por defecto pero con control en móviles */
  font-size: clamp(3rem, 11vw, 7rem);
      margin: 0;
  margin-top: 48px; /* un poquito más abajo */
  /* permitir que las colas de las letras queden visibles fuera de su caja si hace falta */
  overflow: visible;
  display: inline-block;
  padding-inline: 12px;
      opacity: 0;
      background: linear-gradient(90deg, #ff6aa2, #ffd166, #6ef1e0, #ff6aa2);
      background-size: 200% 200%;
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
      animation: riseBounce 0.9s cubic-bezier(.2,.9,.3,1) forwards, float 3s ease-in-out infinite, gradientMove 6s linear infinite;
      animation-delay: 0.6s, 1.5s, 0s;
      animation-fill-mode: forwards;
      font-weight: 400;
      /* sombra sutil y más oscura para mejorar lectura sin el gran halo blanco */
      text-shadow: 0 6px 18px rgba(0,0,0,0.55);
  letter-spacing: 0.4px;
  /* un poco más de interlínea para que la altura de las letras no se corte */
  line-height: 1.12;
    }

    /* Ajustes específicos para pantallas pequeñas / móviles */
    @media (max-width: 480px) {
      body {
        padding-inline: 14px;
        padding-top: 28px;
      }

      h1 {
        /* títulos más grandes en móviles pero controlados */
        font-size: clamp(1.8rem, 8.5vw, 3.2rem);
      }

      h2 {
        /* nombre más grande y bien espaciado en móviles */
        font-size: clamp(2.6rem, 12vw, 5.2rem);
        margin-top: 44px;
        padding-inline: 8px;
        line-height: 1.14;
      }
    }

    @keyframes gradientMove {
      0% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
      100% { background-position: 0% 50%; }
    }

    @keyframes popUp {
      0% { transform: scale(0.2); opacity: 0; }
      60% { transform: scale(1.2); opacity: 1; }
      80% { transform: scale(0.95); }
      100% { transform: scale(1); }
    }

    @keyframes riseBounce {
      0% { transform: translateY(100px); opacity: 0; }
      60% { transform: translateY(-20px); opacity: 1; }
      80% { transform: translateY(10px); }
      100% { transform: translateY(0); opacity: 1; }
    }

    @keyframes float {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-10px); }
    }

    canvas {
      position: absolute;
      top: 0;
      left: 0;
      /* asegurar que queda detrás y no cubra nada */
      z-index: -2;
    }
  </style>
</head>
<body>
  <h1 id="title">Happy Birthday</h1>
  <h2 id="name">Massiel</h2>
  <canvas id="fireworks"></canvas>

  <script>
    const canvas = document.getElementById('fireworks');
    const ctx = canvas.getContext('2d');

    function resizeCanvas() {
      const dpr = window.devicePixelRatio || 1;
      canvas.width = window.innerWidth * dpr;
      canvas.height = window.innerHeight * dpr;
      canvas.style.width = window.innerWidth + 'px';
      canvas.style.height = window.innerHeight + 'px';
      // map drawing operations to CSS pixels
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }

    // inicializar tamaño y actualizar al redimensionar
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);

    const h1 = document.getElementById("title");
    const h2 = document.getElementById("name");

    function getTextBoxes() {
      const rect1 = h1.getBoundingClientRect();
      const rect2 = h2.getBoundingClientRect();
      return [
        {x: rect1.left, y: rect1.top, w: rect1.width, h: rect1.height},
        {x: rect2.left, y: rect2.top, w: rect2.width, h: rect2.height}
      ];
    }

    class Projectile {
      constructor(x, targetY, color) {
        // store positions in CSS pixels (not the internal canvas pixels)
        this.x = x;
        this.y = canvas.clientHeight;
        this.targetY = targetY;
        this.color = color;
        this.radius = 3;
        this.speedY = -7;
        this.exploded = false;
        this.alpha = 1;
      }

      update(textBoxes) {
        if (!this.exploded) {
          this.y += this.speedY;

          for (let box of textBoxes) {
            if (
              this.x >= box.x &&
              this.x <= box.x + box.w &&
              this.y >= box.y &&
              this.y <= box.y + box.h
            ) {
              this.exploded = true;
              explode(this.x, this.y, this.color);
              return;
            }
          }

          if (this.y <= this.targetY) {
            this.exploded = true;
            explode(this.x, this.y, this.color);
          }
        } else {
          this.alpha -= 0.04;
        }
      }

      draw() {
        if (this.alpha > 0) {
          ctx.save();
          ctx.globalAlpha = this.alpha;
          // convert CSS pixels to internal canvas pixels using current transform
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
          ctx.fillStyle = this.color;
          ctx.fill();
          ctx.restore();
        }
      }
    }

    class Particle {
      constructor(x, y, color) {
        this.x = x;
        this.y = y;
        this.radius = Math.random() * 3 + 2;
        this.color = color;
        this.speedX = (Math.random() - 0.5) * 8;
        this.speedY = (Math.random() - 0.5) * 8;
        this.alpha = 1;
      }

      update() {
        this.x += this.speedX;
        this.y += this.speedY;
        this.alpha -= 0.015;
      }

      draw() {
        if (this.alpha > 0) {
          ctx.save();
          ctx.globalAlpha = this.alpha;
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
          ctx.fillStyle = this.color;
          ctx.fill();
          ctx.restore();
        }
      }
    }

    const colors = ['#ff0040', '#00ffd5', '#ffff00', '#ff8000', '#00ff00', '#ff00ff'];
    let particles = [];
    let projectiles = [];

    function explode(x, y, color) {
      for (let i = 0; i < 30; i++) {
        particles.push(new Particle(x, y, color));
      }
    }

    function animate() {
      ctx.fillStyle = "rgba(0, 0, 0, 0.2)";
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      const textBoxes = getTextBoxes();

      for (let p of projectiles) {
        p.update(textBoxes);
        p.draw();
      }

      for (let p of particles) {
        p.update();
        p.draw();
      }

      projectiles = projectiles.filter(p => !(p.exploded && p.alpha <= 0));
      particles = particles.filter(p => p.alpha > 0);

      requestAnimationFrame(animate);
    }

    setTimeout(() => {
      setInterval(() => {
        // use CSS pixels so items line up with getBoundingClientRect()
        const cssWidth = canvas.clientWidth;
        const cssHeight = canvas.clientHeight;
        const x = Math.random() * cssWidth;
        const targetY = Math.random() * cssHeight * 0.5;
        const color = colors[Math.floor(Math.random() * colors.length)];
        projectiles.push(new Projectile(x, targetY, color));
      }, 700);
      animate();
    }, 1800);
  </script>
</body>
</html>
